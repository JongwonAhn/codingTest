Class2 Array

 배열이란?
- <index, value>의 쌍으로 구성된 집합
- 배열의 순서는 메모리 공간에서 연속적으로 저장됨
- 배열의 인덱스 값을 이용해서 배열의 원소값에 접근하므로 직접 접근 가능
- 메모리 주소값은 실제 메모리의 물리적인 주소값 

 2차원배열
- 행우선배열, 열우선배열 존재
- 행 또는 열 우선 메모리할당에 따라 나뉘며, 보통의 언어는 행 우선 배열

  희소 행렬
- 원소값이 0인 원소가 그렇지 않은 원소보다 많다면 메모리 낭비를 막고 효율성을 높이기 위해 등장
- 추상화 하여 행, 열, 0이 아닌값 을 3개의 열로 표현. 같은 2차원 배열이지만 메모리 절약

Class3 Stack

 스택 이란?
- LIFO로, 순서가 보장되어 있다 - 데이터 입력시 데이터가 어느 위치에 있는지 알수 있다.
- 컴파일러, 재귀호출, 연산자의 계산순서 등 에서 사용됨.
- Create, push(add), pop(delete), top(자바에선peak) 사용
- 자바에서 List를 상속받아 구현함.

Class4 Queue

 큐 란?
- FIFO로, 먼저 들어온 순서대로 처리. 한쪽에서는 삽입 연산만 발생, 다른 한족에서는 삭제 연산만 발생됨
- OS의 순차 작업 스케쥴링, 버퍼(큐에 대기시킴) 에서 사용
- rear(add), front(remove), peak(첫번째 값)
- 자바에서는 LinkedList를 활용해서 Queue를 생성한다.
- Stack, Queue 모두 선형 자료구조에 해당.

Class5 List
 
 리스트 란?
- 일정한 순서의 나열.
- 배열처럼 메모리의 물리적 순서가 아닌 논리적인 순서대로 데이터가 저장됨.
  -> 배열은 인덱스가 데이터가 저장된 물리적 순서를 의미, 리스트는 데이터간 논리적 순서만 유지
  
 LinkedList
- 노드 -> 해당위치의 데이터와 리스트의 다음 원소를 가르키는 링크(주소값)로 구성됨
- LinkedList에서 삭제는 삭제할 노드의 선행 노드의 링크가 삭제할 노드의 후행노드를 가르키게 한다.
- 삽입은 삽입할 노드x 의 링크가 후행 노드가 될 주소값을 가르키고, 선행노드가 될 노드가 x의 주소값을 가르킨다.

Class6 연결리스트의 변형

- 문제점 -> 후행 노드는 쉽게 접근할 수 있지만, 특정 노드의 선행 노드에 대한 접근은
  해드 노드부터 재검색 해야 하는 문제점이 있음.
- 이중 연결 리스트 -> 특정 노드가 후행 노드의 주소값 뿐만 아니라 선행 노드의 주소값을 가르키는
                노드를 갖으므로 선행, 후행 모두 접근 가능.
  
- 원형 연결 리스트 -> 기존 연결리스트에서는 마지막 노드가 가르키는 노드가 없으므로 null이지만,
                 해드노드가 가르키는 가장 앞 노드를 가르키게 하여 원형으로, 어떤 노드도 접근 가능. 기존 단순 연결 리스트와 같은 메모리 공간을 사용하므로 효율적. 
				 
				 
Class7 트리

 트리란?
- 특성을 논리적 계층으로 분류. 검색의 편리함.
- 부모노드와 자식노드의 직접적 연결로 구성
- 루트노드: 트리의 최상의 노드(부모가 없는 노드), 진입차수=0, 레벨=0
- 리프노드: 자식노드가 없는 최하단의 노드, 진출차수= 0
- 노드의 레벨: 루트로부터 그 노드까지 이어진 선(경로) 길이
- 트리의 높이: 루트-> 가장멀리있는노드의 선(경로)+1

 이진트리
- 모든 노드의 차수가 2이하인 트리
- 트리가 전부 다 채워지면 포화이진트리.

Class8 스레드 트리

- 트리에서 마지막 노드들은 하위 트리를 가르키는 주소값이Null이다. 이를 활용하기위해서 스레드 트리가 등장.
- 스레드 트리란, 이 null의 위치에 스레드라는 포인터를 추가하여 트리 순회를 편리하게 한것이다.
  여기서 스레드란, 순회 방법에 따른 방문 순서를 유지하는 포인터이다. 
- 전위순회 : P - L - R (Parent, Left, Right)
- 중위순회 : L - P - R
- 후위순회 : L - R - P
- 스레드 구현방법 1) 포인터 필드 추가 방법
  L스레드에 다음 스레드 저장, R스레드에 이전 스레드 저장
  트리에 속한 모든 노드들을 순회할 수 있으나, 추가 기억장소를 사용한다는 부담이 생김
- 스레드 구현방법 2) 리프노드에 있는 사용하지 않는 포인터 활용방법
  전위, 중위 순회시 리프노드에 오른쪽포인터의 null위치에 다음 스레드를 가르킴.
  추가 기억장소를 사용하지 않아도 되는 장점, 후위순회시 불가능 하여 추가 프로그래밍 필요
  
Class9 Heap
  
  우선순위 큐
- 대기 리스트에서 항상 우선순위가 높은 작업이 먼저 처리되는 구조
- 삭제시, 우선순위가 가장 높은 데이터를 front로 이동시켜 삭제. (데이터 연산이 두번 일어남)
- 추가시, 우선순위에 상관없이 rear로 맨 마지막 위치에 삽입 

  힢
- 피라미드 모양으로 쌓아 올린 더미, 항상 가장 위에 있는 것을 우선 꺼내는 구조
  즉, 정렬된 완전 이진트리로, 부모노드는 자식노드보다 우선순위가 높음
  힢은 우선순위 큐를 구현한 자료구조.
  
  최소힢
- 루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 가짐
- 같은 레벨끼리의 값은 비교하지 않으며 오로지 부모와 자식노드로 비교.
- 최대힢은 그의 정 반대.

Class10 선택트리, 숲, 이진트리 개수

 선택트리
- 합병정렬을 효율적으로 하기 위해 선택드리를 사용한다.
- 선택트리에는 승자트리(낮은값을 위로), 패자트리(높은갚을 위로) 가 사용된다.

 숲
- 분리된 트리의 집합
- 트리에서 루트(다른노드)를 제거하면 숲이 되며, 반대로 연결하면 트리를 만들수있음 
- 숲의 이진트리 변환은, 왼쪽은 자식노드, 오른쪽은 형제노드로 나열하여 이진트리로 변환 가능.
- 